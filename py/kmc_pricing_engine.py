"""
KMC pricing engine v1

Reads a KMC CSV file, applies margin and fee rules from config/kmc_pricing_config.json,
and writes a repriced CSV to output/.
Generated by Ecom Copilot scaffolding.
"""

from __future__ import annotations

import csv
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime

ROOT = Path(__file__).resolve().parents[1]
CONFIG_PATH = ROOT / "config" / "kmc_pricing_config.json"


@dataclass
class KmcConfig:
    supplier_code: str
    dropship_fee: float
    handling_fee: float
    misc_fee: float
    min_gross_margin: float
    max_gross_margin: float
    marketplaces: List[Dict[str, Any]]
    shipping_rules: Dict[str, Any]
    input_file: Path
    output_file: Path
    columns: Dict[str, str]


def _to_float(val: Any, default: float = 0.0) -> float:
    if val is None:
        return default
    if isinstance(val, (int, float)):
        return float(val)
    s = str(val).strip().replace("$", "").replace(",", "")
    if not s:
        return default
    try:
        return float(s)
    except ValueError:
        return default


def load_config() -> KmcConfig:
    if not CONFIG_PATH.exists():
        raise FileNotFoundError(f"Config not found: {CONFIG_PATH}")
    data = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))

    csv_cfg = data.get("csv", {})
    cols = csv_cfg.get("columns", {})
    input_rel = csv_cfg.get("input_file", "input/kmc_source.csv")
    output_rel = csv_cfg.get("output_file", "output/kmc_pricing_repriced.csv")

    return KmcConfig(
        supplier_code=data.get("supplier_code", "KMC"),
        dropship_fee=_to_float(data.get("dropship_fee", 0.0)),
        handling_fee=_to_float(data.get("handling_fee", 0.0)),
        misc_fee=_to_float(data.get("misc_fee", 0.0)),
        min_gross_margin=_to_float(data.get("min_gross_margin", 0.25)),
        max_gross_margin=_to_float(data.get("max_gross_margin", 0.5)),
        marketplaces=list(data.get("marketplaces", [])),
        shipping_rules=dict(data.get("shipping_rules", {})),
        input_file=ROOT / input_rel,
        output_file=ROOT / output_rel,
        columns={
            "sku": cols.get("sku", "SKU"),
            "name": cols.get("name", "Description"),
            "brand": cols.get("brand", "Brand"),
            "cost": cols.get("cost", "Cost"),
            "upc": cols.get("upc", "UPC"),
            "length": cols.get("length", "Length"),
            "width": cols.get("width", "Width"),
            "height": cols.get("height", "Height"),
            "weight": cols.get("weight", "Weight"),
        },
    )


def estimate_shipping(weight: float, length: float, width: float, height: float, rules: Dict[str, Any]) -> float:
    """
    Very simple placeholder shipping estimator.

    Uses rules["default"] with:
      base: base cost
      per_pound: cost per lb (min 1lb)

    Later this will be replaced with live carrier API calls.
    """
    default = rules.get("default", {})
    base = _to_float(default.get("base", 3.0))
    per_lb = _to_float(default.get("per_pound", 1.0))

    if weight <= 0:
        weight = 1.0
    return base + per_lb * weight


def compute_prices() -> None:
    """
    Core logic:

    base_cost = item_cost + dropship_fee + handling_fee + misc_fee + shipping_cost

    Let:
      f = marketplace fee percent (e.g. 0.15 for 15%)
      m = desired gross margin (profit / sale_price), including marketplace fee as a cost

    We want:
      sale_price - base_cost - f * sale_price = m * sale_price

      sale_price * (1 - f - m) = base_cost
      sale_price = base_cost / (1 - f - m)

    This matches your "total cost includes marketplace fee, then add margin" logic
    without having to iterate.
    """
    cfg = load_config()

    if not cfg.input_file.exists():
        raise FileNotFoundError(f"Input CSV not found: {cfg.input_file}")

    cfg.output_file.parent.mkdir(parents=True, exist_ok=True)

    rows_out: List[Dict[str, Any]] = []

    with cfg.input_file.open("r", encoding="utf-8-sig", newline="") as f_in:
        reader = csv.DictReader(f_in)
        col = cfg.columns

        for src in reader:
            sku = str(src.get(col["sku"], "")).strip()
            name = str(src.get(col["name"], "")).strip()
            brand = str(src.get(col["brand"], "")).strip()
            upc = str(src.get(col["upc"], "")).strip()

            cost = _to_float(src.get(col["cost"]))
            length = _to_float(src.get(col["length"]))
            width = _to_float(src.get(col["width"]))
            height = _to_float(src.get(col["height"]))
            weight = _to_float(src.get(col["weight"]))

            shipping_cost = estimate_shipping(weight, length, width, height, cfg.shipping_rules)

            base_cost = cost + cfg.dropship_fee + cfg.handling_fee + cfg.misc_fee + shipping_cost

            for mp in cfg.marketplaces:
                mp_name = str(mp.get("name", "")).strip() or "unknown"
                fee_rate = _to_float(mp.get("fee_percent", 0.0))

                for margin in (cfg.min_gross_margin, cfg.max_gross_margin):
                    if margin <= 0:
                        continue

                    denom = 1.0 - fee_rate - margin
                    if denom <= 0:
                        # skip impossible combinations (fee + margin >= 100%)
                        continue

                    price = base_cost / denom

                    fee_amount = price * fee_rate
                    profit = price - base_cost - fee_amount
                    roi = (profit / base_cost) if base_cost > 0 else 0.0

                    rows_out.append(
                        {
                            "supplier": cfg.supplier_code,
                            "sku": sku,
                            "name": name,
                            "brand": brand,
                            "upc": upc,
                            "cost": round(cost, 4),
                            "dropship_fee": round(cfg.dropship_fee, 4),
                            "handling_fee": round(cfg.handling_fee, 4),
                            "misc_fee": round(cfg.misc_fee, 4),
                            "shipping_cost": round(shipping_cost, 4),
                            "base_cost": round(base_cost, 4),
                            "marketplace": mp_name,
                            "marketplace_fee_percent": fee_rate,
                            "margin_target": margin,
                            "price": round(price, 2),
                            "fee_amount": round(fee_amount, 4),
                            "profit": round(profit, 4),
                            "roi": round(roi, 4),
                        }
                    )

    if not rows_out:
        print("No rows produced. Check config margins and marketplaces.")
        return

    fieldnames = [
        "supplier",
        "sku",
        "name",
        "brand",
        "upc",
        "cost",
        "dropship_fee",
        "handling_fee",
        "misc_fee",
        "shipping_cost",
        "base_cost",
        "marketplace",
        "marketplace_fee_percent",
        "margin_target",
        "price",
        "fee_amount",
        "profit",
        "roi",
    ]

    with cfg.output_file.open("w", encoding="utf-8", newline="") as f_out:
        writer = csv.DictWriter(f_out, fieldnames=fieldnames)
        writer.writeheader()
        for row in rows_out:
            writer.writerow(row)

    print(f"Wrote {len(rows_out)} repriced rows to: {cfg.output_file}")
    print("Done.")


if __name__ == "__main__":
    print(f"[{datetime.now().isoformat(timespec='seconds')}] KMC pricing engine v1")
    compute_prices()
